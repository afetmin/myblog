# 不要再问我原型了-原型与原型链

**实例与构造函数原型之间有直接的联系，但实例与构造函数之间没有。**

每个函数都有一个属性，就是prototype，函数的prototype指向了一个对象，这个对象就是调用该构造函数创建的**实例**的原型。

可以这么理解：每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型“继承”属性。实例person与Person.prototype之间的关系通过 **proto** 连接这是每一个JavaScript对象(除了 null )都具有的一个属性，叫__proto__，这个属性会指向该对象的原型。

![https://cdn.nlark.com/yuque/0/2021/png/2349196/1617932783252-f7093d41-d7e3-4b4e-aa2c-036b4d8860f4.png#align=left&display=inline&height=173&margin=%5Bobject%20Object%5D&name=image.png&originHeight=208&originWidth=579&size=11670&status=done&style=none&width=481](https://cdn.nlark.com/yuque/0/2021/png/2349196/1617932783252-f7093d41-d7e3-4b4e-aa2c-036b4d8860f4.png#align=left&display=inline&height=173&margin=%5Bobject%20Object%5D&name=image.png&originHeight=208&originWidth=579&size=11670&status=done&style=none&width=481)

```jsx
function Person() {}
var person = new Person();
console.log(person.__proto__ === Person.prototype); // true
```

![https://cdn.nlark.com/yuque/0/2021/png/2349196/1617932937740-a8cea22a-8d8d-4a6c-8d49-5588c67eebd1.png#align=left&display=inline&height=262&margin=%5Bobject%20Object%5D&name=image.png&originHeight=290&originWidth=576&size=16952&status=done&style=none&width=520](https://cdn.nlark.com/yuque/0/2021/png/2349196/1617932937740-a8cea22a-8d8d-4a6c-8d49-5588c67eebd1.png#align=left&display=inline&height=262&margin=%5Bobject%20Object%5D&name=image.png&originHeight=290&originWidth=576&size=16952&status=done&style=none&width=520)

每个原型都有一个 **constructor** 属性指向关联的构造函数。

```jsx
function Person() {}
console.log(Person === Person.prototype.constructor); // true
```

![https://cdn.nlark.com/yuque/0/2021/png/2349196/1617932993749-e44581cc-6d4f-4aab-b270-c7fec8f235b4.png#align=left&display=inline&height=235&margin=%5Bobject%20Object%5D&name=image.png&originHeight=290&originWidth=580&size=19667&status=done&style=none&width=470](https://cdn.nlark.com/yuque/0/2021/png/2349196/1617932993749-e44581cc-6d4f-4aab-b270-c7fec8f235b4.png#align=left&display=inline&height=235&margin=%5Bobject%20Object%5D&name=image.png&originHeight=290&originWidth=580&size=19667&status=done&style=none&width=470)

原型也是一个对象，那就可以通过Object构造函数生成，所以

![https://cdn.nlark.com/yuque/0/2021/png/2349196/1617933151060-de8b7890-44c7-44a5-ac55-674478e50329.png#align=left&display=inline&height=401&margin=%5Bobject%20Object%5D&name=image.png&originHeight=477&originWidth=590&size=31470&status=done&style=none&width=496](https://cdn.nlark.com/yuque/0/2021/png/2349196/1617933151060-de8b7890-44c7-44a5-ac55-674478e50329.png#align=left&display=inline&height=401&margin=%5Bobject%20Object%5D&name=image.png&originHeight=477&originWidth=590&size=31470&status=done&style=none&width=496)

Object.prototype.__proto__ 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。

### 一些细节

![https://cdn.nlark.com/yuque/0/2021/png/2349196/1617933217706-4c6ff28f-6f7e-4d89-be76-18fbc3b0e30a.png#align=left&display=inline&height=465&margin=%5Bobject%20Object%5D&name=image.png&originHeight=525&originWidth=590&size=33592&status=done&style=none&width=523](https://cdn.nlark.com/yuque/0/2021/png/2349196/1617933217706-4c6ff28f-6f7e-4d89-be76-18fbc3b0e30a.png#align=left&display=inline&height=465&margin=%5Bobject%20Object%5D&name=image.png&originHeight=525&originWidth=590&size=33592&status=done&style=none&width=523)

### constructor

```jsx
function Person() {}
var person = new Person();
console.log(person.constructor === Person); // true
```

当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：

```jsx
person.constructor === Person.prototype.constructor
```

### **proto**

绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.__proto__ 时，可以理解成返回了 Object.getPrototypeOf(obj)。

### 真的是继承吗？

最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话，就是：

继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。

### Function.__proto__ === Function.prototype

Function 作为一个内置对象，是运行前就已经存在的东西，所以根本就不会根据自己生成自己，就是先有的 Function，然后实现上把原型指向了 Function.prototype，但是我们不能倒过来推测因为Function.__proto__ === Function.prototype，所以 Function 调用了自己生成了自己。

### 完整的原型链

![https://cdn.nlark.com/yuque/0/2021/png/2349196/1617933846288-c7bcf590-77a6-4f98-b343-774620e4316f.png#align=left&display=inline&height=586&margin=%5Bobject%20Object%5D&name=image.png&originHeight=586&originWidth=520&size=152366&status=done&style=none&width=520](https://cdn.nlark.com/yuque/0/2021/png/2349196/1617933846288-c7bcf590-77a6-4f98-b343-774620e4316f.png#align=left&display=inline&height=586&margin=%5Bobject%20Object%5D&name=image.png&originHeight=586&originWidth=520&size=152366&status=done&style=none&width=520)

**什么是原型链？**

当对象查找一个属性的时候，如果没有在自身找到，那么就会查找自身的原型，如果原型还没有找到，那么会继续查找原型的原型，直到找到 Object.prototype 的原型时，此时原型为 null，查找停止。 这种通过**原型链接的逐级向上的查找链**被称为原型链

**什么是原型继承？**

一个对象可以使用另外一个对象的属性或者方法，就称之为继承。具体是通过将这个对象的原型设置为另外一个对象，这样根据原型链的规则，如果查找一个对象属性且在自身不存在时，就会查找另外一个对象，相当于一个对象可以使用另外一个对象的属性和方法了。

使用 **Object.prototype.toString.call()** 判断数据类型

**__proto__** 与内部的 **[[Prototype]]  不一样**。

**__proto__** 是 **[[Prototype]]** 的 getter/setter。